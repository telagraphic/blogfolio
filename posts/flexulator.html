---
title: Flexulator
layout: page
permalink: /flexulator
---

<article class="post">

  <section class="post__header">
    <h2>Flexulator</h2>
    <time>1/2019</time>
  </section>

  <section class="post__banner">
    <img src="{{site.baseurl}}assets/img/posts/post-logo.png" alt="Flexulator Logo"></img>
  </section>


  <section class="post__article">
    <p>
      A couple of years ago I was learning <b>Flexbox</b> and <b>Grid</b> for web page layouts. Both standards
      have changed front end development for the better and modernized the tools front end devs so badly needed.
    </p>

    <p>
      While learning flexbox, I got inspired to build <a href="https://www.flexulator.com/">Flexulator</a> a handy tool that visually illustrates
      how the spacing algorithm works. The first version was made in 2018 and I decided to update the website with an improved look and refactor the spaghetti code.
    </p>

    <p>
      In this post I'll cover some javascript refactoring, build tooling process, some UI/UX improvements and how to stay motivated while working
      on a side-project.
    </p>
  </section>

  <section class="post__article">
    <h3>Inspiration</h3>
    <p>
      Flexbox's spacing algorithm isn't intuitive when you are first learning, but several
      <a href="https://www.smashingmagazine.com/2018/08/flexbox-display-flex-container/">CSS experts have</a>
      written great articles
      <a href="https://chriswrightdesign.com/experiments/flexbox-adventures/">explaining the math behind</a> how it works.
    </p>

    <p>
      Firefox Dev Tools inspired the look and feel, I cold copied styles and colors to give the site
      the look and feel of a web tool. Check out how they designed the
      <a href="https://hacks.mozilla.org/2019/01/designing-the-flexbox-inspector/">Flexbox inspector</a>.
    </p>
  </section>

  <section class="post__article">
    <h3>Improvements</h3>
    <p>
      The first version was a <a href="https://github.com/telagraphic/flexulator/blob/original-master/js/scripts.js">500 line spaghetti code mess of code</a>
      that worked, but it needed improvements.
      The UI was good, I got a lot of compliments.
    </p>
  </section>

  <section class="post__list">
    <ul>
      <li>
        Calling 10+ functions that loop over the same elements and update their text fields.
        Could be improved with first reading, calculating and then writing to the DOM.
      </li>
      <li>
        Lack of code design, which is fine but would help in keeping the calculation functions easier to write.
        An <b>Observer</b> design pattern could be a good idea for the next version.
      </li>
      <li>
        An explanation of each formula value.
      </li>
      <li>
        A easy way to get the calculator into a grow and shrink "mode".
        User has to manually change values to trigger shrink condition.
      </li>
      <li>
        Any performance boost's for a faster page load.
      </li>
    </ul>
  </section>


  <section class="post__article">
    <h3>Workflow</h3>

    <p>
      Side projects require evenings and weekends and a workflow that optimizes
      for small wins and incremental progress.
      Time contraints force you to be more intentional and specific with your work.
    </p>

    <p>
      I use <b>Github Issues, Milestones and Kanban Board</b> to break down features into smaller tasks which are
      easily tracked.
      I use these tools like a Trello board, referencing articles and stackoverflow posts for
      each issue/card as well keeping checklists of all the steps required to complete the task.
    </p>

    <p>
      If you keep track of each work session and document it,
      you'll see how much work goes into a "simple" component of a feature.
      This is crucial for learning and planning your next side-project, if that's your thing.
    </p>

    <p>
      Having worked on agile teams as a test analyst, we were required to track our progress
      on our current iteration cards. It built a habit of keeping a history,
      very helpful for many reasons like proving that you actually do work at your job.
    </p>

    <p>
      Unlike working on an agile team, side projects
      are full of unknowns as you start to build it. You realize things will require more time as you need to learn about a technology,
      research the numerous possible approaches and try out several failed attempts.
    </p>

    <figure class="post__figure-video">
      <video autoplay loop muted playsinline>
        <source src="{{site.baseurl}}assets/flexulator/github-issues.webm" type="video/webm">
        <source src="{{site.baseurl}}assets/flexulator/github-issues.mp4" type="video/mp4">
      </video>
      <figcaption>
        <h5>
          Github Issues
        </h5>
      </figcaption>
    </figure>

    <h3>Quantifying Work</h3>
    <p>
      <b>Milestones</b> are great for breaking down your project into smaller chunks and then further decomposed into cards.
      Quantifying your work helps to wrap your head around the problem. Maybe you want to learn a new technology paired with
      skills you have picked up. Planning this out will help you stay on course when you get lost in the weeds and frustrated.
      Maintaining that big picture can maintain motivation and provide clarity.
    </p>

    <p>
      Most of my efforts will be refactoring the javascript and making some design changes. Here is a table of
      all the UI elements that will require new code.
    </p>
  </section>

  <section class="post__table">
    <table>
      <thead>
        <tr>
          <th>UI</th>
          <th>Total</th>
          <th>Desc</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Events</td>
          <td>3</td>
          <td>resize, add, remove</td>
        </tr>
        <tr>
          <td>Shrink Fields</td>
          <td>14</td>
          <td>text fields</td>
        </tr>
        <tr>
          <td>Grow Fields</td>
          <td>10</td>
          <td>text fields</td>
        </tr>
        <tr>
          <td>Buttons</td>
          <td>4</td>
          <td>update flex item values</td>
        </tr>
        <tr>
          <td>Tabs</td>
          <td>3</td>
          <td></td>
        </tr>
      </tbody>
    </table>
  </section>

  <section class="post__article">
    <p>
      That's a grand total of 34 UI elements to code and design. That's a lot more work than it seems when you first
      start out and understanding this helps you not lose motivation when you are going slower than you anticipated.
    </p>
  </section>

  <section class="post__article">
    <h3>Grow vs. Shrink</h3>
    <p>
      Buttons at the bottom of the form allow the user to toggle between grow and shrink scenarios.
      This really helps to see the how the two formula's work right in the browser.
    </p>

    <p>
      The <b>grow</b> button will make each flex-item size only 100px so that the <b>total-flex-basis</b> is significantly smaller than the container.
      The <b>shrink</b> button does the opposite, increasing each flex item size to make the <b>total-flex-basis</b> exceed the container size.
    </p>

    <figure class="post__figure-video">
      <video autoplay loop muted playsinline>
        <source src="{{site.baseurl}}assets/flexulator/grow-shrink-mode.webm" type="video/webm">
        <source src="{{site.baseurl}}assets/flexulator/grow-shrink-mode.mp4" type="video/mp4">
      </video>
      <figcaption>
        <h5>
          Grow & Shrink Modes
        </h5>
      </figcaption>
    </figure>
  </section>

  <section class="post__article">
    <h3>Grow and Shrink Explained</h3>
    <p>
      I break the math down into a multi-step process that hopefully makes it understandable as to how the
      spacing algorithm works. A nice animation helps too.
      Heavily referencing <a href="https://www.madebymike.com.au/writing/understanding-flexbox/">Mike Riethmuller</a>
      here.
    </p>

    <figure class="post__figure-video">
      <video autoplay loop muted playsinline>
        <source src="{{site.baseurl}}assets/flexulator/flex-example-demo.webm" type="video/webm">
        <source src="{{site.baseurl}}assets/flexulator/flex-example-demo.mp4" type="video/mp4">
      </video>
      <figcaption>
        <h5>
          Flex Formula
        </h5>
      </figcaption>
    </figure>
  </section>


  <section class="post__article">
    <h3>Critical CSS Inlining</h3>
    <p>
      I've heard about inlining above the fold styles or critical CSS and had to try it out.
      There are several npm packages out there and I went with <a href="https://github.com/addyosmani/critical">critical</a> by Addy Osmani.
      It's super easy to setup and get going, it also offers multiple viewport sizes.
      Add this to your build process and it will improve performance which you can check with Chrome's <a href="https://developers.google.com/web/tools/lighthouse">Lighthouse</a>
    </p>

    <p>
      In the code below, I'm running critical against the <b>/dist</b> directory which will read the <b>index.html</b>
      and output a new index.html in the same directory, overwriting the original.
    </p>
  </section>

  <section class="post__code-snippet">
    <pre>
      <code class="language-js">
        var critical = require('critical');

        critical.generate({
          inline: true,
          base: 'dist',
          src: 'index.html',
          target: {
            html: 'index.html'
          },
          minify: true,
          dimensions: [
            {
              width: 320,
              height: 480
            },
            {
              width: 2000,
              height: 1000
            }
          ]
        });
      </code>
    </pre>
  </section>

  <section class="post__article">
    <p>
      With our above the fold critical css inlined into our page, you will want to
      <a href="https://github.com/filamentgroup/loadCSS/">load your CSS asynchronously</a> to prevent unnecessary page rendering delay.
      CSS is typically loaded at the top of the page and will block page rendering.
    </p>
  </section>


  <section class="post__article">
    <h3>Javascript Refactor</h3>
    <p>
      The first version was a 500 line spaghetti code mess of code that worked, but it needed improvements.
      When reviewing the code, it dawned on me that the shrink calculation in the third step was wrong.
      There are enough steps in the calculation to get things crossed up and some javascript objects could
      help keep my code better organized.
    </p>

    <p>
      After writing some psuedo-code on paper, I determined a simple logic flow
      of <b>1)</b> reading values, <b>2)</b> doing calculations and then <b>3)</b> writing them to the DOM upon a resize or flex-item addition or removal.
      This provided a simple model of thinking about how to structure my code.
    </p>

    <h3>Component Structure</h3>
    <p>
      The flex item is really the main component of the tool.
      Each flex item has it's own flex state reflected in the four sections below.
    </p>
  </section>


  <figure class="post__figure">
    <img src="{{site.baseurl}}assets/flexulator/flex-item-outline.png" alt="Flex Item Outline">
    <figcaption>
      <h5>
        Flex Item Component
      </h5>
    </figcaption>
  </figure>

  <section class="post__article">
    <p>
      Each flex item object would have to keep track of each of these attributes on the UI.
      I set about creating a <b>selectors</b> object that references each child element within the parent element, an <b>elements</b> object that
      stored those elements for reading and writing, and finally a <b>flexulations</b> object to be used for reading/writing the flex values
      that are re-calculated on a browser resize or flex-item form change.
    </p>

    <p>
      The UI will be modified with a function
      that reads the new <b>flexulations</b> and updates the DOM <b>elements</b>. You'll notice there is a <b>container</b> property
      that will keep track of the flex-parent item values. It will be needed in the formula for determining how much space is available.
    </p>

    <p>
      When a user makes changes on the <b>form</b>, that items' flex values are updated
      inline on the object which is stored in the <b>styles</b> property.
      The rest of the flex-item functions use these properties for reading, calculating and updating each item.
      Each value on the UI get's it own function.
    </p>
  </section>

  <section class="post__code-snippet">
    <pre>
      <code class="language-js">
        style: {
          grow: 0,
          shrink: 0,
          flexBasis: 0
        },
        form: {
          width: 0,
          grow: 0,
          shrink: 0,
          flexBasis: 0
        },
        flexulations: {
          container: {},
          itemWidth: 0,
          grow: {},
          shrink: {}
        },
        elements: {
          self: null,
          form: {},
          flexulations: {
            container: {},
            grow: {},
            shrink: {}
          }
        },
        selectors: {
          form: {},
          flexulations: {
            container: {},
            grow: {},
            shrink: {}
          }
        }
      </code>
    </pre>
  </section>

  <section class="post__article">
    <h3>Calculating</h3>
    <p>
      Most of the shrink functions are reading from the <b>flexulations</b> object and calculating other values used
      in the formula section.
      The <b>shrink factor</b> needs to be rounded to the 6th decimal to accurately reflect the browser calculation.
    </p>
  </section>

  <section class="post__code-snippet">
    <pre>
      <code class="language-js">
        updateItemShrinkBasis: function() {
          this.flexulations.shrink.valueBasisTotal = this.flexulations.shrink.value * this.flexulations.shrink.itemBasis;
        },
        returnItemShrinkBasis: function() {
          return this.flexulations.shrink.valueBasisTotal;
        },
        updateShrinkBasisTotal: function(shrinkBasisTotal) {
          this.flexulations.shrink.basisTotal = shrinkBasisTotal;
          this.updateShrinkFactor();
          this.updateShrinkComputedWidth();
          this.writeItemFlexulations();
        },
        updateShrinkFactor: function() {
          let shrinkQuotient = parseFloat(this.flexulations.shrink.itemBasis) * parseFloat(this.flexulations.shrink.value);
          this.flexulations.shrink.factor = parseFloat(shrinkQuotient) / parseFloat(this.flexulations.shrink.basisTotal);
        },
        updateShrinkComputedWidth: function() {
          let shrinkComputedWidth = this.flexulations.shrink.factor.toFixed(6) * this.flexulations.container.remainingSpace;
          this.flexulations.shrink.computedWidth = shrinkComputedWidth.toFixed(0);
        },
      </code>
    </pre>
  </section>

  <section class="post__article">
    <h3>Flex Parent</h3>
    <p>
      The flex-parent keeps track of the flex-items that are added and removed as well as setting up all the events.
      This pattern resembles the <b>Observer</b> pattern but does not follow it strictly in a code sense.
    </p>
  </section>

  <section class="post__code-snippet">
    <pre>
      <code class="language-js">
        elements: {
          container: null,
          flexItems: null
        },
        flexValues: {
          width: 0,
          flexBasisTotal: 0,
          remainingSpace: 0
        },
        flexItems: [],
        functionality...
      </code>
    </pre>
  </section>


  <section class="post__article">
    <h3>Flex Basis</h3>
    <p>
      Getting the total flex basis uses the <b>reduce</b> method to return the total basis from each item in the DOM
      and then writes this to array of flex-items that are built from the object we saw above.
      We also save it the flex-parent object as it is required to get the remaining space.
    </p>
  </section>

  <section class="post__code-snippet">
    <pre>
      <code class="language-js">
        updateFlexTotalBasis: function () {
          let flexBasisTotal = flexulator.elements.flexItems.reduce((basisSum, flexItem) => {
            return basisSum + parseInt(flexItem.style.flexBasis);
          }, 0);

          flexulator.flexValues.flexBasisTotal = flexBasisTotal;

          flexulator.flexItems.forEach(item => {
            item.flexulations.container.flexBasisTotal = flexBasisTotal;
          });
        },
      </code>
    </pre>
  </section>

  <section class="post__article">
    <h3>Browser Resize</h3>
    <p>
      I could have put this in debounce function but I'm only updating text fields and there is no serious
      performance hit with constant updates. Plus, it is nice to see the values update in real time.
      We call five functions that update the container, item and the example values in the tabs section.
    </p>
  </section>

  <section class="post__code-snippet">
    <pre>
      <code class="language-js">
        updateResize: function() {
          window.addEventListener('resize', function() {
            flexulator.updateWidth();
            flexulator.updateRemainingSpace();
            flexulator.updateFlexItemsContainerValues();
            flexulator.updateFlexItemGrowFormulaExample();
            flexulator.updateFlexItemShrinkFormulaExample();
          })
        },
      </code>
    </pre>
  </section>

</article>